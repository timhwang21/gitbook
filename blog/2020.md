# 2020

## April

### 2020-4-5

#### [Slack's pre-launch memo](https://medium.com/@stewart/we-dont-sell-saddles-here-4c59524d650d)

Some interesting nuggets here:

1. Our position is different than the one many new companies find themselves in: we are not battling it out in a large, well-defined market with clear incumbents... and that means we can’t limit ourselves to tweaking the product; **we need to tweak the market too**.
2. What we are selling is not the software product — the set of all the features, in their specific implementation — because there are just not many buyers for this software product...
However, if we are selling “a reduction in the cost of communication” or “zero effort knowledge management” or “making better decisions, faster” or “all your team communication, instantly searchable, available wherever you go” or “75% less email” or some other valuable result of adopting Slack, we will find many more buyers. That’s why what we’re selling is organizational transformation. The software just happens to be the part we’re able to build & ship (and the means for us to get our cut).
3. The reason for saying we need to do ‘an exceptional, near-perfect job of execution’ is this: When you want something really bad, you will put up with a lot of flaws. But if you do not yet know you want something, your tolerance will be much lower. That’s why it is especially important for us to build a beautiful, elegant and considerate piece of software. Every bit of grace, refinement, and thoughtfulness on our part will pull people along. Every petty irritation will stop them and give the impression that it is not worth it. That means we have to find all those petty irritations, and quash them. We need to look at our own work from the perspective of a new potential customer and actually see what’s there. Does it make sense? Can you predict what’s going to happen when you click that button or open that menu? Is there sufficient feedback to know if the click or tap worked? Is it fast enough? If I read the email on my phone and click the link, is it broken?.. It is always harder to do this with one’s own product: we skip over the bad parts knowing that we plan to fix it later. We already know the model we’re using and the terms we use to describe it. It is very difficult to approach Slack with beginner’s mind. But we have to, all of us, and we have to do it every day, over and over and polish every rough edge off until this product is as smooth as lacquered mahogany.

## March

### 2020-3-25

#### Engineering empowerment

My current company is quite unique compared to previous places I've worked, in that every engineer essentially has carte blanche with regards to how they prioritize their work. This is actually quite a lot more stressful than I imagined it would be, because the onus is on you to make sure you are prioritizing the _right_ thing. In the past, I've always had a project manager steering the ship.

When your peers and your managers expect that you are talented enough to make the right call, you will second guess yourself a lot. Context switching is quite exhausting for me, and I prefer to immerse myself in one project and get it to the magical point where it is "done." However, when there are five or six balls you have to juggle at once, you're always afraid of blocking someone else, or leaving a customer unhappy.

On the flip side, this is a strong indication of trust that the leaders trust the individual contributors enough to give them this degree of responsibility. It's a learning experience, but I feel incredibly lucky to be working where I am now!

One sub-topic I find interesting is the prioritization of customer requests over foundational work. Customer requests are additive and short term: each completed request improves the relationship with a single customer (and each dropped ball hurts it). On the other hand, foundational work is multiplicative: a strong foundation improves the product for everyone; however, if individual customer requests are dropped while working on foundation, the multiplicand decreases despite the multiplier increasing, possibly resulting in a net loss of value. The gold standard is to find a way to architect customer requests such that they _become_ foundational work, and improve the platform for everyone in a way that ideally cuts down requests in this domain from other customers.

#### Vim as a code review tool

I'm playing with [using my editor as my primary code review tool](https://github.com/timhwang21/dotfiles/blob/master/settings/.gitconfig#L34).

The primary advantage is context. By viewing the diff in your editor, you can easily jump to any definition or type whose meaning isn't immediately clear from the diff. I find that when reviewing code in the browser, I often have to follow along in my editor anyways for full understanding.

Secondly, there's speed. I've used quite a few code review tools in the past, and Gitlab and Bitbucket stand out to me as handling large diffs extraordinarily poorly. In your editor, you can easily hop between files and tabs instantaneously. Directory-wide searching is trivial as well.

Finally, testing ideas is incredibly easy. I often want to double-check the accuracy of some comment I'm leaving, so I have to open my editor and navigate to the file I'm currently viewing on the browser, make my change, and test it. When your editor is your code review tool, you can make your changes the instant they come to mind, with very little friction.

The biggest source of friction I've been running into is leaving comments. Right now I've just been leaving them inline in code, and then doing a diff when complete and copying the comments into the browser. As you can imagine, this is quite annoying.

A more minor grievance is discovery. While Github has a rich command line ecosystem, it's not immediately obvious how I would query and navigate a list of all open PRs on Bitbucket, which is our current code review tool. Currently, I still have to use the browser to actually get to the PR I am reviewing to check it out.

### 2020-3-24

#### [Margin considered harmful](https://mxstbr.com/thoughts/margin)

I strongly agree with this, and am glad that I'm getting some validation about pushing to enforce this on teams I've been on previously.

I've been using CSS-grid even for single-column, two-dimensional layouts, because `grid-gap` is such a great abstraction and results in incredibly standardized layouts. And it's incredibly easy to add responsiveness if needed -- just tweak the column count based on the page size!

This is a great motivator for me to step up my technical communications skills, though. This article is succinct, yet persuasive and informative..

### 2020-3-21

#### Practical explanation of folds

People joke about the monad curse, in that once you understand monads, you lose the ability to explain them in a sensible way. Sometimes this "curse" is genericized to cover any nontrivial functional programming concept.

[lexi-lambda](https://lexi-lambda.github.io/) seems to be an exception to this rule. Here's a great explanation nested in a code review about when to use each type of fold, with concrete examples: [`foldl` vs. `foldr` illustrated](https://github.com/hasura/graphql-engine/pull/2933#discussion_r328821960)

### 2020-3-11

#### Micro brands revisited

[Why all the Warby Parker clones are now imploding](https://marker.medium.com/why-all-the-warby-parker-clones-are-now-imploding-44bfcc70a00c)

1. As more brands arise, customer acquisition gets more expensive due to increased advertising costs. Very interesting analogy of "[CAC is the new rent](https://www.inc.com/magazine/201805/tom-foster/direct-consumer-brands-middleman-warby-parker.html)".
2. Digital advertising is less mature (or maybe scaleable) than anyone thought? As these companies scale up, they start finding that physical billboards in high-traffic locations are more effective than digital advertising. Similarly, brands that sought to bypass having to be physically stocked are now fighting for those very spots.
3. Associated with the above, overly aggressive emphasis on growth due to heavy courting of VCs.

This conclusion somewhat parallels findings from the gig economy:

1. Tech investments do allow you to cut costs and be more nimble... but seemingly only up to a certain scale.
2. Part of the reason costs are lower in the first place are solely due to undersaturation of the digital space.

Another interesting case study of Casper as a rare public micro brand follows. I won't summarize it here, but worth a read.

### 2020-3-8

#### Vim dispatch

(Seedlings of a future reference page.)

Useful dispatch recipes:

```sh
:Dispatch yarn
:Dispatch yarn jest %
:Dispatch rubocop -a %
:Dispatch docker-compose restart
:Dispatch git fetch
```

Caveats:

- Does not work for tty-needing commands, e.g. tig, `git commit`...
- Does not work with aliases
- Note that vim-fugitive already handles pull, push, etc. asynchronously.

## January

### 2020-1-20

#### Haskell's regexp library

...is probably the most expressive I've ever seen.

```haskell
module Main where

import           Text.Regex.Posix

match = "fee fi fo fum" =~ "fo"
-- ()
-- Returns empty? Or errors without FlexibleContexts. Type inference fails. Or does it?

-- By specifying boolean, we get T/F depending on if a match exists
match :: Bool
-- True

-- Or we can specify Int and get the match count
match :: Int
-- 1

-- Or we can specify String and get the match text
match :: String
-- "fo"

-- Ask for a (Int,Int) tuple and we get the match index and length
match :: (Int, Int)
-- (7,2)
```

There are several interesting things to unpack here. Right off the bat, we have a function with a polymorphic return value in a strict statically typed language. That alone is notable. How is this possible?

Let's take a closer look. When inspecting the type of `=~` with `:t (=~)` in GHCi, we get:

```haskell
(=~)
  :: (RegexMaker Regex CompOption ExecOption source,
      RegexContext Regex source1 target) =>
     source1 -> source -> target
```

It turns out the return value is a value of types `RegexContext` and `Regex`. Without diving deeper into the implementation of these types, we know that either `RegexContext` or `Regex` is the source of this magic polymorphism. Specifically, this is implemented using [pattern matching](http://hackage.haskell.org/package/regex-base-0.94.0.0/docs/src/Text.Regex.Base.Context.html#line-332): several instances are declared, with different return values based on the type of `target`, which is the [last type parameter of `RegexContext`](http://hackage.haskell.org/package/regex-base-0.94.0.0/docs/src/Text.Regex.Base.RegexLike.html#RegexContext). In regular usage, if the expected type of `target` is clear from context, no type annotation is needed: the type system just "does the right thing."

In an object oriented language, `RegexContetxt` might be implemented as a class with instance methods like `.asBool()`, `.asTuple()`, etc. However, the consumer is still responsible for calling the correct method, whereas here the return type logic lives entirely at the type level! There is no runtime cost at all. This results in a beautifully elegant developer experience.

### 2020-1-16

#### A somewhat elegant way to ensure list nonemptiness

When working with lists with an indeterminate length, it often makes sense to treat the list as being of type `[Maybe t]`.

Thus, the following idiom can be used to concisely ensure nonemptiness without using `Data.List.NonEmpty` or a related type.

```haskell
list1 :: [Maybe Int]
list1 = [Just 1, Just 2, Just 3]
maximum list1
-- Just 3

list2 :: [Maybe Int]
list2 = []
maximum list2
-- Error!

safeMaximum = maximum . (Nothing:) -- cons-es Nothing to any list
safeMaximum list1
-- Just 3
safeMaximum list2
-- Nothing
```

### 2020-1-15

#### [Blue-green deploys with K8s](https://kubernetes.io/blog/2018/04/30/zero-downtime-deployment-kubernetes-jenkins/)

![Diagram](https://d33wubrfki0l68.cloudfront.net/5a87649bfab8bd84f95c288e8eb0f01c52274e12/7dd66/images/blog/2018-04-30-zero-downtime-deployment-kubernetes-jenkins/resources.png)

### 2020-1-4

#### [OSX: Have Finder open files in vim](https://thepugautomatic.com/2015/02/open-in-iterm-vim-from-finder/)

Slightly modified and added to my dotfiles [here](https://github.com/timhwang21/dotfiles/commit/e221fd7df5d78b38acd7fd0aa12d4ed5e8713300), though it's not really a dotfile. TODO: Find a better solution for including self-written scripts and applications for new machine setup.

Source: (Applescript really is the ugliest language ever.)

```applescript
on run {input, parameters}
	set filename to POSIX path of input
	set cmd to "clear;cd `dirname " & filename & "`;vim " & filename
	tell application "iTerm"
		tell the current window
			create tab with default profile
			tell the current session
				write text cmd
			end tell
		end tell
	end tell
end run
```

### 2020-1-3

#### Bolster tests while refactoring

I ran into an idea that's novel to me today, that is apparently common in the Haskell community. When refactoring, the old implementation is kept around in its entirety, and then acts as a test model for the new implementation for as long as is necessary. This is _slightly_ more robust than just keeping around some list of fixtures for specs.

This is partially enabled by the Haskell test ecosystem having good DX around autogenerating primitive fixtures and running a barrage of them against your code, but that's a tractable problem in other languages.

### 2020-1-2

#### Stripe's ecosystem

As a user, Stripe's accounts ecosystem is a thing of beauty. Pay for something with Stripe once, and if you visit the checkout page of another vendor using Stripe, you are automatically contacted with a verification code that imports your payment details automatically. Shopify's system is somewhat similar but Stripe's implementation is so low friction it actually brought a tear to my eye. Will definitely be drawing inspiration from here for work.

### 2020-1-1

#### [Chain of Command](https://github.com/timhwang21/chain-of-command)

After months of procrastination, I've finally gotten this to a feature-complete v1 stage. It's a fairly simple Haskell program that analyzes your shell history to help you identify areas you can optimize with aliases.
