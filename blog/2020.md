# 2020

## March

### 2020-3-11

#### Micro brands revisited

[Why all the Warby Parker clones are now imploding](https://marker.medium.com/why-all-the-warby-parker-clones-are-now-imploding-44bfcc70a00c)

1. As more brands arise, customer acquisition gets more expensive due to increased advertising costs. Very interesting analogy of "[CAC is the new rent](https://www.inc.com/magazine/201805/tom-foster/direct-consumer-brands-middleman-warby-parker.html)".
2. Digital advertising is less mature (or maybe scaleable) than anyone thought? As these companies scale up, they start finding that physical billboards in high-traffic locations are more effective than digital advertising. Similarly, brands that sought to bypass having to be physically stocked are now fighting for those very spots.
3. Associated with the above, overly aggressive emphasis on growth due to heavy courting of VCs.

This conclusion somewhat parallels findings from the gig economy:

1. Tech investments do allow you to cut costs and be more nimble... but seemingly only up to a certain scale.
2. Part of the reason costs are lower in the first place are solely due to undersaturation of the digital space.

Another interesting case study of Casper as a rare public micro brand follows. I won't summarize it here, but worth a read.

### 2020-3-8

#### Vim dispatch

(Seedlings of a future reference page.)

Useful dispatch recipes:

```sh
:Dispatch yarn
:Dispatch yarn jest %
:Dispatch rubocop -a %
:Dispatch docker-compose restart
:Dispatch git fetch
```

Caveats:

- Does not work for tty-needing commands, e.g. tig, `git commit`...
- Does not work with aliases
- Note that vim-fugitive already handles pull, push, etc. asynchronously.

## January

### 2020-1-20

#### Haskell's regexp library

...is probably the most expressive I've ever seen.

```haskell
module Main where

import           Text.Regex.Posix

match = "fee fi fo fum" =~ "fo"
-- ()
-- Returns empty? Or errors without FlexibleContexts. Type inference fails. Or does it?

-- By specifying boolean, we get T/F depending on if a match exists
match :: Bool
-- True

-- Or we can specify Int and get the match count
match :: Int
-- 1

-- Or we can specify String and get the match text
match :: String
-- "fo"

-- Ask for a (Int,Int) tuple and we get the match index and length
match :: (Int, Int)
-- (7,2)
```

There are several interesting things to unpack here. Right off the bat, we have a function with a polymorphic return value in a strict statically typed language. That alone is notable. How is this possible?

Let's take a closer look. When inspecting the type of `=~` with `:t (=~)` in GHCi, we get:

```haskell
(=~)
  :: (RegexMaker Regex CompOption ExecOption source,
      RegexContext Regex source1 target) =>
     source1 -> source -> target
```

It turns out the return value is a value of types `RegexContext` and `Regex`. Without diving deeper into the implementation of these types, we know that either `RegexContext` or `Regex` is the source of this magic polymorphism. Specifically, this is implemented using [pattern matching](http://hackage.haskell.org/package/regex-base-0.94.0.0/docs/src/Text.Regex.Base.Context.html#line-332): several instances are declared, with different return values based on the type of `target`, which is the [last type parameter of `RegexContext`](http://hackage.haskell.org/package/regex-base-0.94.0.0/docs/src/Text.Regex.Base.RegexLike.html#RegexContext). In regular usage, if the expected type of `target` is clear from context, no type annotation is needed: the type system just "does the right thing."

In an object oriented language, `RegexContetxt` might be implemented as a class with instance methods like `.asBool()`, `.asTuple()`, etc. However, the consumer is still responsible for calling the correct method, whereas here the return type logic lives entirely at the type level! There is no runtime cost at all. This results in a beautifully elegant developer experience.

### 2020-1-16

#### A somewhat elegant way to ensure list nonemptiness

When working with lists with an indeterminate length, it often makes sense to treat the list as being of type `[Maybe t]`.

Thus, the following idiom can be used to concisely ensure nonemptiness without using `Data.List.NonEmpty` or a related type.

```haskell
list1 :: [Maybe Int]
list1 = [Just 1, Just 2, Just 3]
maximum list1
-- Just 3

list2 :: [Maybe Int]
list2 = []
maximum list2
-- Error!

safeMaximum = maximum . (Nothing:) -- cons-es Nothing to any list
safeMaximum list1
-- Just 3
safeMaximum list2
-- Nothing
```

### 2020-1-15

#### [Blue-green deploys with K8s](https://kubernetes.io/blog/2018/04/30/zero-downtime-deployment-kubernetes-jenkins/)

![Diagram](https://d33wubrfki0l68.cloudfront.net/5a87649bfab8bd84f95c288e8eb0f01c52274e12/7dd66/images/blog/2018-04-30-zero-downtime-deployment-kubernetes-jenkins/resources.png)

### 2020-1-4

#### [OSX: Have Finder open files in vim](https://thepugautomatic.com/2015/02/open-in-iterm-vim-from-finder/)

Slightly modified and added to my dotfiles [here](https://github.com/timhwang21/dotfiles/commit/e221fd7df5d78b38acd7fd0aa12d4ed5e8713300), though it's not really a dotfile. TODO: Find a better solution for including self-written scripts and applications for new machine setup.

Source: (Applescript really is the ugliest language ever.)

```applescript
on run {input, parameters}
	set filename to POSIX path of input
	set cmd to "clear;cd `dirname " & filename & "`;vim " & filename
	tell application "iTerm"
		tell the current window
			create tab with default profile
			tell the current session
				write text cmd
			end tell
		end tell
	end tell
end run
```

### 2020-1-3

#### Bolster tests while refactoring

I ran into an idea that's novel to me today, that is apparently common in the Haskell community. When refactoring, the old implementation is kept around in its entirety, and then acts as a test model for the new implementation for as long as is necessary. This is _slightly_ more robust than just keeping around some list of fixtures for specs.

This is partially enabled by the Haskell test ecosystem having good DX around autogenerating primitive fixtures and running a barrage of them against your code, but that's a tractable problem in other languages.

### 2020-1-2

#### Stripe's ecosystem

As a user, Stripe's accounts ecosystem is a thing of beauty. Pay for something with Stripe once, and if you visit the checkout page of another vendor using Stripe, you are automatically contacted with a verification code that imports your payment details automatically. Shopify's system is somewhat similar but Stripe's implementation is so low friction it actually brought a tear to my eye. Will definitely be drawing inspiration from here for work.

### 2020-1-1

#### [Chain of Command](https://github.com/timhwang21/chain-of-command)

After months of procrastination, I've finally gotten this to a feature-complete v1 stage. It's a fairly simple Haskell program that analyzes your shell history to help you identify areas you can optimize with aliases.
